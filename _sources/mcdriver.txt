.. _mcdriver:

========
Solution
========


To run this code in parallel, we will use IPython's :class:`LoadBalancedView` class,
which distributes work to the engines using dynamic load balancing. This
view is a wrapper of the :class:`Client` class shown in
the previous example. The parallel calculation using :class:`LoadBalancedView` can
be found in the file :file:`mcpricer.py`. The code in this file creates a
:class:`LoadBalancedView` instance and then submits a set of tasks using
:meth:`LoadBalancedView.apply` that calculate the option prices for different
volatilities and strike prices. The results are then plotted as a 2D contour
plot using Matplotlib.

.. literalinclude:: _static/code/mcpricer/mcdriver.py
   :language: python

To use this code, start an IPython cluster using :command:`ipcluster`, open
IPython in the pylab mode with the file :file:`mcdriver.py` in your current
working directory and then type:

.. sourcecode:: ipython

    In [7]: run mcdriver.py
    Submitted tasks:  [0, 1, 2, ...]

Once all the tasks have finished, the results can be plotted using the
:func:`plot_options` function. Here we make contour plots of the Asian
call and Asian put options as function of the volatility and strike price:

.. sourcecode:: ipython

    In [8]: plot_options(sigma_vals, K_vals, prices['acall'])

    In [9]: plt.figure()
    Out[9]: <matplotlib.figure.Figure object at 0x18c178d0>

    In [10]: plot_options(sigma_vals, K_vals, prices['aput'])

These results are shown in the two figures below. On a 8 core cluster the
entire calculation (10 strike prices, 10 volatilities, 100,000 paths for each)
took 30 seconds in parallel, giving a speedup of 7.7x, which is comparable
to the speedup observed in our previous example.

.. image:: figs/asian_call.*

.. image:: figs/asian_put.*

